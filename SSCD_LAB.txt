//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			-----------------------------------SSCD LAB-------------------------------                            
												Bhuvanapalli Aditya Pranav
												1SI16CS026
												6th Semester A Section
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1 FCFS Scheduling
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
using namespace std;
float avgwait=0,avgta=0;
typedef struct
{
    int name;
    float a,b;
    float start,stop;
    float wait,ta;
}process;
void gantt(process p[100],int n)
{
    int i,j,dummy=0;
    process v;
    for(i=1;i<n;i++)
    {
        j=i-1;
        v=p[i];
        while(j>=0 && p[j].a>v.a)
        {
            p[j+1]=p[j];
            j=j-1;
        }
        p[j+1]=v;
    }

    for(i=0;i<n;i++)
    {
        //p[i].start=dummy;
        if(p[i].a>dummy)
        {
            p[i].start=p[i].a;
        }
        else
        {
            p[i].start=dummy;
        }
        p[i].stop=p[i].start+p[i].b;
        dummy=p[i].stop;
    }

    for(i=0;i<n;i++)
    {
        p[i].wait=p[i].start-p[i].a;
        p[i].ta=p[i].stop-p[i].a;
    }

    for(i=0;i<n;i++)
    {
        avgwait=avgwait+p[i].wait;
        avgta=avgta+p[i].ta;
    }

    avgwait=avgwait/n;
    avgta=avgta/n;

}
int main()
{
    int i,n;
    printf("Enter no. of process :");
    scanf ("%d",&n);
    process p[n];
    for(i=0;i<n;i++)
    {
        p[i].name=i+1;
        printf("P%d : ",p[i].name);
        printf("\nArrival = ");
        scanf("%f",&p[i].a);
        printf("\nBurst = ");
        scanf("%f",&p[i].b);
    }
    printf("\nProcess\tArrival\tBurst\n");
    for(i=0;i<n;i++)
    {
        printf("%d\t%f\t%f\n",p[i].name,p[i].a,p[i].b);
    }
    gantt(p,n);
    printf("\nProcess\tArrival\tBurst\n");
    for(i=0;i<n;i++)
    {
        printf("%d\t%f\t%f\n",p[i].name,p[i].a,p[i].b);
    }
    printf("Avg. wait = %f",avgwait);
    printf("Avg. TA   = %f",avgta);
    return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
2 Preemptive Priority Scheduling
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
using namespace std;
typedef struct
{
    int a,b,p;
    int rem,wait,ta;
}process;
process p[100];
int n,time=0;
void input()
{
    int i;
    cout<<"Enter n : ";cin>>n;
    cout<<"Process\tArrival\tBurst\tPriority"<<endl;
    for(i=0;i<n;i++)
    {
        cout<<"P"<<i<<"\t";
        cin>>p[i].a>>p[i].b>>p[i].p;
        p[i].rem=p[i].b;
        p[i].wait=p[i].ta=0;
    }
}
void gantt()
{
    int i,j,min,time=0,ind;
    while(1)
    {
        min=999;
        for(i=0;i<n;i++)
        {
            if(p[i].p<min && p[i].rem>0 && p[i].a<=time)
            {
                ind=i;
                min=p[i].p;
            }
        }
        if(min==999)
            break;
        p[ind].rem--;
        time++;
        if(p[ind].rem==0)
        {
            p[ind].ta=time-p[ind].a;
            p[ind].wait=p[ind].ta-p[ind].b;
        }
    }
}
void calcwait()
{
    int i;
    float avgwait=0;
    cout<<"\nWaiting Times :"<<endl;
    for(i=0;i<n;i++)
    {
        cout<<"P"<<i<<" : "<<p[i].wait<<endl;
        avgwait+=p[i].wait;
    }
    avgwait/=n;
    cout<<"\nAvg waiting time = "<<avgwait<<endl;
}
void calcta()
{
    int i;
    float avgta=0;
    cout<<"\nTurn Around Times : "<<endl;
    for(i=0;i<n;i++)
    {
        cout<<"P"<<i<<" : "<<p[i].ta<<endl;
        avgta+=p[i].ta;
    }
    avgta/=n;
    cout<<"\nAvg waiting time = "<<avgta<<endl;
}
int main()
{
    input();
    gantt();
    calcwait();
    calcta();
    return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
3 Producer and Consumer Problem
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
using namespace std;
int mutex=1,empty=5,full=0,buffer[5],top=-1;
int wait(int s)
{
    return --s;
}
int signal(int s)
{
    return ++s;
}
void producer()
{
    mutex=wait(mutex);
    empty=wait(empty);
    cout<<"Produce  : ";cin>>buffer[++top];
    cout<<"Produced : "<<buffer[top]<<endl;
    cout<<"Empty : "<<empty<<endl;
    full=signal(full);
    mutex=signal(mutex);
}
void consumer()
{
    mutex=wait(mutex);
    full=wait(full);
    cout<<"Consumed : "<<buffer[top--]<<endl;
    cout<<"Full : "<<full<<endl;
    empty=signal(empty);
    mutex=signal(mutex);
}
int main()
{
    int ch;
    while(1)
    {
        cout<<"1. Produce 2. Consume 3. Exit"<<endl<<"Your Choice :";
        cin>>ch;
        switch(ch)
        {
            case 1: if(mutex==1 && empty>0)
                        producer();
                    else
                        cout<<"Buffer is Full"<<endl;
                    break;
            case 2: if(mutex==1 && full>0)
                        consumer();
                    else
                        cout<<"Buffer is Empty"<<endl;
                    break;
            case 3: return 0;
        }
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
4 BANKERS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include<stdio.h>
#include<stdlib.h>
const int MAX=10;
int allocation[MAX][MAX],max[MAX][MAX],available[MAX],work[MAX],need[MAX][MAX],finish[MAX],safe[MAX],m,n;
void input()
{
	int i,j;
	printf("Enter no. of resource types: ");
	scanf("%d",&m);
	printf("Enter no. of processes: ");
	scanf("%d",&n);
	printf("Enter the available resources vector :\n");
	for(i=0;i<m;i++)
	{
		scanf("%d",&available[i]);
	}
	printf("Enter the allocation matrix :\n");
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
		{
			scanf("%d",&allocation[i][j]);
		}
	}
	printf("Enter the MAX matrix :\n");
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
		{
			scanf("%d",&max[i][j]);
		}
	}
}
void calc_need()
{
	int i,j;
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
		{
			need[i][j]=max[i][j]-allocation[i][j];
		}
	}
}
void disp_need()
{
	int i,j;
	printf("Content of NEED matrix :\n");
	for(i=0;i<n;i++)
	{
		for(j=0;j<m;j++)
		{
			printf("%d\t",need[i][j]);
		}
		printf("\n");
	}
}
int needlesswork(int i)
{
	int j;
	for(j=0;j<m;j++)
	{
		if(need[i][j]>work[j])
		{
			return 0;
		}
	}
	return 1;
}
int safety()
{
	int i,j,k=0;
	for(i=0;i<m;i++)
	{
		work[i]=available[i];
	}
	for(i=0;i<n;i++)
	{
		finish[i]=0;
	}
	while(1)
	{
		for(i=0;i<n;i++)
		{
			if(!finish[i] && needlesswork(i))
			{
				for(j=0;j<m;j++)
				{
					work[j]=work[j]+allocation[i][j];
				}
				finish[i]=1;
				safe[k++]=i;
				break;
			}
		}
		if(i==n)
		{
			for(j=0;j<n;j++)
			{
				if(!finish[j])
				{
					return 0;
				}
			}
			return 1;
		}
	}
}
int main()
{
	int i,isSafe=0;
	input();
	calc_need();
	disp_need();
	isSafe=safety();
	if(isSafe)
	{
		printf("\nThe Safe Sequence is\n");
		for(i=0;i<n;i++)
		{
			printf("P%d\n",safe[i]);
		}
	}
	else 
	{
		printf("No safe sequence exists.");
	}
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
5 Memory Allocation Techniques
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include<stdio.h>
#include<stdlib.h>
int frag[100],b[100],f[100],i,j,nb,nf,temp,lowest=10000,highest=0;
int bf[100],ff[100];
void firstfit()
{
    for(i=1;i<=nf;i++)
    {
        for(j=1;j<=nb;j++)
        {
            if(bf[j]!=1)
            {
                temp=b[j]-f[i];
                if(temp>=0)
                {
                    ff[i]=j;
                    break;
                }
            }
        }
        frag[i]=temp;
        bf[ff[i]]=1;
    }
    
}
void bestfit()
{
    for(i=1;i<=nf;i++)
    {
        for(j=1;j<=nb;j++)
        {
            if(bf[j]!=1)
            {
                temp=b[j]-f[i];
                
                if(temp>=0&&lowest>temp)
                {
                    ff[i]=j;
                    lowest=temp;
                }
            }
        }
        frag[i]=lowest;
        bf[ff[i]]=1;
        lowest=10000;
    }
}
void worstfit()
{
    for(i=1;i<=nf;i++)
    {
        for(j=1;j<=nb;j++)
        {
            if(bf[j]!=1)
            {
                temp=b[j]-f[i];
            
                if(temp>=0&&highest<temp)
                {
                    ff[i]=j;
                    highest=temp;
                }
            }
        }
        frag[i]=highest;
        bf[ff[i]]=1;
        highest=0;
    }
}
int main()
{
    int ch;
    printf("\nEnter the number of blocks:");
    scanf("%d",&nb);
    printf("Enter the number of files:");
    scanf("%d",&nf);
    printf("\nEnter the size of the blocks:-\n");
    for(i=1;i<=nb;i++)
        scanf("%d",&b[i]);
    printf("Enter the size of the files :-\n");
    for(i=1;i<=nf;i++)
        scanf("%d",&f[i]);
    printf("\nEnter the choice:\n1:FIRST-FIT\t2:BEST-FIT\t3:WORST-FIT\t4:Exit\n");
    scanf("%d",&ch);
    switch(ch)
    {
        case 1:firstfit();break;
        case 2:bestfit();break;
        case 3:worstfit();break;
        case 4:exit(0);
    }
    printf("\nFile_no:\tFile_size :\tBlock_no:\tBlock_size:\tFragement");
    for(i=1;i<=nf;i++)
        printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d\n",i,f[i],ff[i],b[ff[i]],frag[i]);
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
6 Page Replacement Algorithms
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <stdio.h>
using namespace std;
char frames[10];
string s;
int N;
int haspagefault(char ch)
{
    int i;
    for(i=0;i<N;i++)
    {
        if(frames[i]==ch)
        {
            return 0;
        }
    }
    return 1;
}
int fifo()
{
    int i,j;
    int point=-1;
    int count=0;
    for(i=0;i<N;i++)
    {
        frames[i]='X';
    }
    cout<<"PAGE\t\tFRAMES"<<endl;
    for(i=0;i<s.length();i++)
    {
        cout<<s[i]<<"\t\t";
        if(haspagefault(s[i]))
        {
            point=(point+1)%N;
            frames[point]=s[i];
            count++;
            for(j=0;j<N;j++)
            {
                cout<<frames[j]<<" ";
            }
        }
        cout<<endl;
    }
    return count;
}

int lru()
{
    int i,j,k,highest,dist[10],ind;
    int point=-1;
    int count=0;
    for(i=0;i<N;i++)
    {
        frames[i]='X';
    }
    cout<<"PAGE\t\tFRAMES"<<endl;
    for(i=0;i<s.length();i++)
    {
        cout<<s[i]<<"\t\t";
        if(haspagefault(s[i]))
        {
            if(i<N)
            {
                point=(point+1)%N;
            }
            else
            {
                highest=0;
                for(j=0;j<N;j++)
                {
                    for(k=i-1;k>=0;k--)
                    {
                        if(s[k]==frames[j])
                        {
                            dist[j]=i-k;
                            break;
                        }
                    }
                    if(dist[j]>highest)
                    {
                        highest=dist[j];
                        ind=j;
                    }
                }
                point=ind;
            }
            //point=(point+1)%N;
            frames[point]=s[i];
            count++;
            for(j=0;j<N;j++)
            {
                cout<<frames[j]<<" ";
            }
        }
        cout<<endl;
    }
    return count;
}

int lfu()
{
    int i,j,k,lowest,freq[10],ind;
    int point=-1;
    int count=0;
    for(i=0;i<N;i++)
    {
        frames[i]='X';
    }
    cout<<"PAGE\t\tFRAMES"<<endl;
    for(i=0;i<s.length();i++)
    {
        cout<<s[i]<<"\t\t";
        if(haspagefault(s[i]))
        {
            if(i<N)
            {
                point=(point+1)%N;
            }
            else
            {
                lowest=999;
                for(j=0;j<N;j++)
                {
                    freq[j]=0;
                    for(k=i-1;k>=0;k--)
                    {
                        if(s[k]==frames[j])
                        {
                            freq[j]++;
                        }
                    }
                    if(freq[j]<lowest)
                    {
                        lowest=freq[j];
                        ind=j;
                    }
                }
                point=ind;
            }
            //point=(point+1)%N;
            frames[point]=s[i];
            count++;
            for(j=0;j<N;j++)
            {
                cout<<frames[j]<<"("<<freq[j]<<")"<<" ";
            }
        }
        cout<<endl;
    }
    return count;
}

int main()
{

    cout<<"Enter N : ";cin>>N;
    cout<<"Enter string :"<<endl;cin>>s;
	cout<<"No. of page faults using FIFO 	:"<<fifo()<<endl;
	cout<<"No. of page faults using LRU  	:"<<lru()<<endl;
	cout<<"No. of page faults using LFU     :"<<lfu()<<endl;
	return 0;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
7 Token Recognition
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int main()
{
	char str[100],ch;
	int i=0,state=0;
	printf("Enter string : \n");
	gets(str);
	while(str[i]!='\0')
	{
		ch=str[i++];
		switch(state)
		{
			case 0: 
					if(ch=='a')state=1;
					else if(ch=='b')state=4;
					else state=6;
					break;
			case 1:
					if(ch=='b')state=2;
					else if(ch=='a')state=5;
					else state=6;
					break;
			case 2:
					if(ch=='b')state=3;
					else state=6;
					break;
			case 3:
					if(ch=='b')state=4;
					else state=6;
					break;
			case 4:
					if(ch=='b')state=4;
					else state=6;
					break;
			case 5:
					if(ch=='a')state=5;
					else if(ch=='b')state=4;
					else state=6;
					break;
			case 6:
					state=6;
					break;
		}
	}
	if(state==0 || state==1 || state==5)
		printf("\nString accepted by a*\n");
	else if(state==2 || state==4)
		printf("\nString accepted by a*b+\n");
	else if(state==3)
		printf("\nString accepted by abb\n");
	else 
		printf("\nString not accepted by any of the following regex \n 1. a*\n 2. a*b+\n 3. abb\n");
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
8 Identifier Recognition
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include<stdio.h>
#include<iostream>
#include<stdlib.h>
#include<string.h>
using namespace std;
int check(char s[100])
{
	int i,n;
	n=strlen(s);
	if(isalpha(s[0]) || s[0]=='_')
	{
		for(i=1;i<n;i++)
			if(!(isalnum(s[i]) || s[i]=='_'))
				return 0;
		return 1;
	}	
	return 0;
}
int main()
{
	char reg[100];
	string res="is not a C identifier";
	printf("Enter the string : ");
	gets(reg);
	if(check(reg))
		res="is a C identifier";
	cout<<reg<<" : "<<res<<endl;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
9 First of a Grammar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
#include <iostream>
#include<cstring>
using namespace std;
char nonterminal[100],temp;
string terminal[100];
int N;
string stack;
int top=-1;

void push(char ch)
{
    top++;
    stack.append(1,ch);
}

int find(string str,char ch)
{
    int i;
    for(i=0;i<str.length();i++)
    {
        if(ch==str[i])
        {
            return 1;
        }
    }
    return 0;
}

void grammar()
{
    int i;
    N=8;
    nonterminal[0]='E';
    nonterminal[1]='X';
    nonterminal[2]='X';
    nonterminal[3]='T';
    nonterminal[4]='Y';
    nonterminal[5]='Y';
    nonterminal[6]='F';
    nonterminal[7]='F';
    terminal[0]="TX";
    terminal[1]="+TX";
    terminal[2]="#";
    terminal[3]="FY";
    terminal[4]="*FY";
    terminal[5]="#";
    terminal[6]="i";
    terminal[7]="(E)";
    for(i=0;i<N;i++)
    {
        cout<<nonterminal[i]<<" -> "<<terminal[i]<<endl;
    }
    cout<<endl;
}

void grammar2()
{
    int i;
    N=6;
    nonterminal[0]='S';
    nonterminal[1]='S';
    nonterminal[2]='S';
    nonterminal[3]='T';
    nonterminal[4]='X';
    nonterminal[5]='X';
    terminal[0]="a";
    terminal[1]="^";
    terminal[2]="(T)";
    terminal[3]="SX";
    terminal[4]=",SX";
    terminal[5]="#";
    for(i=0;i<N;i++)
    {
        cout<<nonterminal[i]<<" -> "<<terminal[i]<<endl;
    }
    cout<<endl;
}

string first(char X)
{
    int i=0,j=0,k;
    char ch;
    string F;
    string F1;
    for(i=0;i<N;i++)
    {
        if(nonterminal[i]==X)
        {
            if(isupper(terminal[i][0]))
            {
                F1=first(terminal[i][0]);
                for(k=0;k<F1.length();k++)
                {
                    if(!find(F,F1[k]))
                    {
                        F.append(1,F1[k]);
                    }
                }
            }
            else if(terminal[i]=="#")
            {
                F.append("#");
            }
            else
            {
                F.append(1,terminal[i][0]);
            }
        }
    }
    return F;
}
int main()
{
    int i=0;
    string fir;
    grammar();
    for(i=0;i<N;i++)
    {
        if(!find(stack,nonterminal[i]))
        {
            push(nonterminal[i]);
            fir=first(nonterminal[i]);
            cout<<"FIRST("<<nonterminal[i]<<") = {"<<fir<<"}"<<endl;
        }
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
10 Predictive Parsing Table
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

#include <iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
string terminal[100],first[100],follow[100];
int N;
char nonterminal[100];
void inputgrammar()
{
    int i;
    char ch;
    cout<<"Enter no. of productions : ";cin>>N;
    cout<<"Enter the grammar :"<<endl;
    for(i=0;i<N;i++)
    {
        cin>>nonterminal[i]>>ch>>ch>>terminal[i];
    }
}
int find(string str,char ch)
{
    int i;
    for(i=0;i<str.length();i++)
    {
        if(ch==str[i])
        {
            return 1;
        }
    }
    return 0;
}
void predictiveparsingtable()
{
    int i,j;
    for(i=0;i<N;i++)
    {
        for(j=0;j<first[i].length();j++)
        {
            if(first[i][j]!='#')
                cout<<"M["<<nonterminal[i]<<","<<first[i][j]<<"] = "<<nonterminal[i]<<"->"<<terminal[i]<<endl;
        }
        if(find(first[i],'#'))
        {
            for(j=0;j<follow[i].length();j++)
            {
                cout<<"M["<<nonterminal[i]<<","<<follow[i][j]<<"] = "<<nonterminal[i]<<"->"<<terminal[i]<<endl;
            }
        }
    }
}
int main()
{
    int i,j;
    inputgrammar();
    cout<<"FIRST :"<<endl;
    for(i=0;i<N;i++)
    {
        cout<<"FIRST("<<terminal[i]<<") = ";cin>>first[i];
    }
    cout<<"FOLLOW :"<<endl;
    for(i=0;i<N;i++)
    {
        cout<<"FOLLOW("<<nonterminal[i]<<") = ";cin>>follow[i];
    }
    cout<<endl<<"Predictive Parsing Table Entries"<<endl;
    predictiveparsingtable();
    return 0;
}

void grammar()
{
    int i;
    N=8;
    nonterminal[0]='E';
    nonterminal[1]='X';
    nonterminal[2]='X';
    nonterminal[3]='T';
    nonterminal[4]='Y';
    nonterminal[5]='Y';
    nonterminal[6]='F';
    nonterminal[7]='F';
    terminal[0]="TX";
    terminal[1]="+TX";
    terminal[2]="#";
    terminal[3]="FY";
    terminal[4]="*FY";
    terminal[5]="#";
    terminal[6]="i";
    terminal[7]="(E)";
    for(i=0;i<N;i++)
    {
        cout<<nonterminal[i]<<" -> "<<terminal[i]<<endl;
    }
    cout<<endl;
}

void grammar2()
{
    int i;
    N=6;
    nonterminal[0]='S';
    nonterminal[1]='S';
    nonterminal[2]='S';
    nonterminal[3]='T';
    nonterminal[4]='X';
    nonterminal[5]='X';
    terminal[0]="a";
    terminal[1]="^";
    terminal[2]="(T)";
    terminal[3]="SX";
    terminal[4]=",SX";
    terminal[5]="#";
    for(i=0;i<N;i++)
    {
        cout<<nonterminal[i]<<" -> "<<terminal[i]<<endl;
    }
    cout<<endl;
}

/////////////////////////////////////////////
10 Predictive Parsing with Table
/////////////////////////////////////////////

#include <iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
string terminal[100],first[100],follow[100],t,nt;
int N,Nt,Nnt;
char nonterminal[100];
int M[100][100];
void inputgrammar()
{
     int i;
     char ch;
     cout<<"Enter no. of productions : ";cin>>N;
     cout<<"Enter the grammar :"<<endl;
     for(i=0;i<N;i++)
     {
         cin>>nonterminal[i]>>ch>>ch>>terminal[i];
     }
}
int contains(string str,char ch)
{
    int i;
    for(i=0;i<str.length();i++)
    {
        if(ch==str[i])
        {
            return i;
        }
    }
    return -1;
}
int find(string str,char ch)
{
    int i;
    for(i=0;i<str.length();i++)
    {
        if(ch==str[i])
        {
            return 1;
        }
    }
    return 0;
}
void predictiveparsingtable()
{
    int i,j,x,y;
    for(i=0;i<nt.length();i++)
    {
        for(j=0;j<t.length();j++)
        {
            M[i][j]=-1;
        }
    }
    for(i=0;i<N;i++)
    {
        for(j=0;j<first[i].length();j++)
        {
            if(first[i][j]!='#')
            {
                cout<<"M["<<nonterminal[i]<<","<<first[i][j]<<"] = "<<nonterminal[i]<<"->"<<terminal[i]<<endl;
                x=contains(nt,nonterminal[i]);
                y=contains(t,first[i][j]);
                M[x][y]=i;
                //cout<<"Debug: M["<<x<<","<<y<<"] = "<<nonterminal[M[x][y]]<<"->"<<terminal[M[x][y]]<<endl;
            }

        }
        if(find(first[i],'#'))
        {
            for(j=0;j<follow[i].length();j++)
            {
                cout<<"M["<<nonterminal[i]<<","<<follow[i][j]<<"] = "<<nonterminal[i]<<"->"<<terminal[i]<<endl;
                x=contains(nt,nonterminal[i]);
                y=contains(t,follow[i][j]);
                M[x][y]=i;
                //cout<<"Debug: M["<<x<<","<<y<<"] = "<<nonterminal[M[x][y]]<<"->"<<terminal[M[x][y]]<<endl;
            }
        }
    }
    for(i=0;i<t.length();i++)
    {
        cout<<"\t"<<t[i];
    }
    cout<<endl;
    for(i=0;i<nt.length();i++)
    {
        cout<<nt[i]<<"\t";
        for(j=0;j<t.length();j++)
        {
            if(M[i][j]!=-1)
                cout<<nonterminal[M[i][j]]<<"->"<<terminal[M[i][j]]<<"\t";
            else
                cout<<"\t";
        }
        cout<<endl;
    }
}
int main()
{
    int i,j;
    inputgrammar();
    t="";
    nt="";
    for(i=0;i<N;i++)
    {
        if(!find(nt,nonterminal[i]))
        {
            nt.append(1,nonterminal[i]);
        }
    }
    for(i=0;i<N;i++)
    {
        for(j=0;j<terminal[i].length();j++)
        {
            if(!find(t,terminal[i][j]) && !isupper(terminal[i][j]) && terminal[i][j]!='#')
            {
                t.append(1,terminal[i][j]);
            }
        }
    }
    t.append(1,'$');
    cout<<"Nonterminals = "<<nt<<endl;
    cout<<"Terminals = "<<t<<endl;
    cout<<"FIRST :"<<endl;
    for(i=0;i<N;i++)
    {
        cout<<"FIRST("<<terminal[i]<<") = ";
        cin>>first[i];
    }
    cout<<"FOLLOW :"<<endl;
    for(i=0;i<N;i++)
    {
        cout<<"FOLLOW("<<nonterminal[i]<<") = ";
        cin>>follow[i];
    }
    cout<<endl<<"Predictive Parsing Table Entries"<<endl;
    predictiveparsingtable();
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
11 Recursive Descent Parsing
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include<stdio.h>
using namespace std;
int N,ip=0;
char nonterminal[100];
string terminal[100];
string s;
void grammar()
{
    int i;
    char ch;
    cout<<"Enter N : ";cin>>N;
    cout<<"Enter the productions "<<endl;
    for(i=0;i<N;i++)
    {
        cin>>nonterminal[i]>>ch>>ch>>terminal[i];
    }
}
void nonterminalfn(char X)
{
    int i,j;
    int temp;
    for(i=0;i<N;i++)
    {
        temp=ip;
        if(nonterminal[i]==X)
        {
            for(j=0;j<terminal[i].length();j++)
            {
                if(s[ip]==terminal[i][j])
                {
                    ip++;
                }
                else if(isupper(terminal[i][j]))
                {
                    nonterminalfn(terminal[i][j]);
                }
                else if(terminal[i]=="#")
                {
                    break;
                }
                else
                {
                    ip=temp;
                    break;
                }
            }
        }
    }
}
int main()
{
    grammar();
    while(1)
    {
        ip=0;
        cout<<"Enter string :"<<endl;cin>>s;
        nonterminalfn('S');
        if(ip==s.length())
        {
            cout<<"Success"<<endl;
        }
        else
        {
            cout<<"Failure"<<endl;
        }
    }
    return 0;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
12 Closure of a grammar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include<stdio.h>
using namespace std;
int N;
char nonterminal[100];
string terminal[100];
void grammar()
{
    int i;
    char ch;
    cout<<"Enter N : ";cin>>N;
    cout<<"Enter the productions "<<endl;
    for(i=0;i<N;i++)
    {
        cin>>nonterminal[i]>>ch>>ch>>terminal[i];
    }

    nonterminal[N]='X';
    terminal[N]="S";
    N++;
}
void closure(string s)
{
    int i,k;
    string temp;
    cout<<"\t"<<s<<endl;
    for(k=0;k<s.length();k++)
    {
        if(s[k]=='.')
        {
            k++;
            break;
        }
    }
    for(i=0;i<N;i++)
    {
        if(nonterminal[i]==s[k])
        {
            temp=nonterminal[i];
            temp.append("->.");
            temp.append(terminal[i]);
            closure(temp);
        }
    }

}
int main()
{
    string s;
    grammar();
    while(1)
    {
        cout<<"Enter string :"<<endl;cin>>s;
        cout<<"Closure("<<s<<") = "<<endl;
        cout<<"{"<<endl;
        closure(s);
        cout<<"}"<<endl;
    }
    return 0;
}
